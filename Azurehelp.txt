The error you're encountering (`SEC_ERROR_UNKNOWN_PKCS11_ERROR` and `PEM_read_bio: Expecting: ANY PRIVATE KEY`) suggests that `curl` is having trouble loading the `.p12` certificate or that it's not correctly interpreting the certificate and key from the `.p12` file.

### Let's address this step by step:

#### 1. **Check the `.p12` File**
   Ensure that the `.p12` file is valid and contains both the private key and certificate:

   ```bash
   openssl pkcs12 -in /sw/tis/core/PoetsHfiSharePoint.ap.hedani.net.p12 -noout -info
   ```

   This command will prompt you for the password and then display the contents of the `.p12` file. If this command fails, it means the `.p12` file may be corrupted or the password might be incorrect.

#### 2. **Convert the `.p12` to Separate PEM Files**
   If the `.p12` file is valid but still causing issues, consider converting it to separate PEM files (one for the certificate and one for the private key). 

   **Convert the Private Key:**
   ```bash
   openssl pkcs12 -in /sw/tis/core/PoetsHfiSharePoint.ap.hedani.net.p12 -nocerts -out /sw/tis/core/privatekey.pem -nodes -passin pass:yourpassword
   ```

   **Convert the Certificate:**
   ```bash
   openssl pkcs12 -in /sw/tis/core/PoetsHfiSharePoint.ap.hedani.net.p12 -nokeys -out /sw/tis/core/certificate.pem -passin pass:yourpassword
   ```

   **Note:** Replace `yourpassword` with the actual password for the `.p12` file.

   After converting, modify your script to use these separate PEM files:

   ```ksh
   response=$(curl -X POST \
       -H "Authorization: Bearer $ACCESS_TOKEN" \
       -H "Accept: application/json;odata=verbose" \
       -H "Content-Type: application/octet-stream" \
       --cert /sw/tis/core/certificate.pem --key /sw/tis/core/privatekey.pem \
       --data-binary @"$FILE_CONTENT" \
       "$RESOURCE/_api/web/GetFolderByServerRelativeUrl('$UPLOAD_FOLDER_PATH')/Files/add(url='$FILE_NAME',overwrite=true)" \
       -o /dev/null -w "%{http_code}")
   ```

#### 3. **Ensure the Correct File Paths**
   The error message also indicates that `FILE_CONTENT` is not being found. Ensure that you're pointing to an actual file path instead of using a string for the file content. If you want to create a file dynamically, do so before the `curl` command:

   ```ksh
   echo "This is the content of your file." > /tmp/uploadfile.txt
   TARGET_FILE="/tmp/uploadfile.txt"
   ```

   Then, change the `--data-binary` option to use the file:

   ```ksh
   --data-binary @"$TARGET_FILE"
   ```

#### 4. **Debugging the Configuration File Warning**
   The warning `can't open config file: /usr/local/ssl/openssl.cnf` is usually benign unless your setup requires specific configurations from that file. You can explicitly tell OpenSSL to use a specific configuration file or ignore this warning if it’s not impacting your operation.

### Final Script Example (Using Separate PEM Files):

```ksh
#!/bin/ksh

# Variables
CLIENT_ID="0007bd36-f5b4-4e24-8c8d-e8e931c259aa"
TENANT_ID="fb6ea403-7cf1-4905-810a-fe5547e98204"
RESOURCE="https://ubscloudapc.sharepoint.com"
PRIVATE_KEY_FILE="/sw/tis/core/privatekey.pem"
CERT_FILE="/sw/tis/core/certificate.pem"
UPLOAD_FOLDER_PATH="/teams/cssp16poetshfi1/Documents/UserReports/ConnectionTesting"
FILE_NAME="Rishikesh.txt"
TARGET_FILE="/tmp/uploadfile.txt"

# Create the content file
echo "This is the content of your file." > $TARGET_FILE

# Step 1: Create the JWT Assertion
JWT_HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
JWT_CLAIMS=$(echo -n "{\"aud\":\"https://login.microsoftonline.com/$TENANT_ID/oauth2/token\",\"iss\":\"$CLIENT_ID\",\"sub\":\"$CLIENT_ID\",\"exp\":$(( $(date +%s) + 3600 )),\"nbf\":$(date +%s),\"jti\":\"id$(date +%s)\"}" | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
JWT_SIGNATURE=$(echo -n "$JWT_HEADER.$JWT_CLAIMS" | openssl dgst -sha256 -sign $PRIVATE_KEY_FILE | base64 | tr -d '=' | tr '/+' '_-' | tr -d '\n')
JWT="$JWT_HEADER.$JWT_CLAIMS.$JWT_SIGNATURE"

# Step 2: Request an Access Token from Azure AD
ACCESS_TOKEN=$(curl -s -X POST "https://login.microsoftonline.com/$TENANT_ID/oauth2/token" \
    -d "grant_type=client_credentials" \
    -d "client_id=$CLIENT_ID" \
    -d "client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer" \
    -d "client_assertion=$JWT" \
    -d "resource=$RESOURCE" | grep -o '"access_token":"[^"]*"' | sed 's/"access_token":"//' | sed 's/"//')

# Step 3: Upload the File to SharePoint
response=$(curl -X POST \
    -H "Authorization: Bearer $ACCESS_TOKEN" \
    -H "Accept: application/json;odata=verbose" \
    -H "Content-Type: application/octet-stream" \
    --cert $CERT_FILE --key $PRIVATE_KEY_FILE \
    --data-binary @"$TARGET_FILE" \
    "$RESOURCE/_api/web/GetFolderByServerRelativeUrl('$UPLOAD_FOLDER_PATH')/Files/add(url='$FILE_NAME',overwrite=true)" \
    -o /dev/null -w "%{http_code}")

# Step 4: Check for Success or Failure
if [ "$response" -eq 200 ]; then
    echo "File uploaded successfully!"
else
    echo "Error uploading file. HTTP Status: $response"
fi
```

### Summary:
- Convert your `.p12` file to separate PEM files for the private key and certificate if the `.p12` file is causing issues.
- Ensure you’re providing a valid file path for the file content rather than directly passing a string.
- Verify that all file paths and passwords are correct and that the `.p12` file or PEM files are valid.

Let me know if this resolves the issue or if further troubleshooting is needed!












##########################################################


# Define required variables
v_client_id="your_client_id"
v_tenant_id="your_tenant_id"
v_cert_thumbprint="your_cert_thumbprint"
v_key_cert_path="/path/to/your/privatekey.pem"
v_key_password="your_key_password"
v_file_path="/path/to/uploadfile.txt"
v_sharepoint_url="https://yourtenant.sharepoint.com/sites/yoursite/_api/web/GetFolderByServerRelativeUrl('/Shared Documents')/Files/add(url='uploadfile.txt',overwrite=true)"

# Generate JWT
v_jwt=$(create_JWT $v_client_id $v_tenant_id $v_cert_thumbprint $v_key_cert_path $v_key_password)

# Request an access token
v_token_command="curl -X POST https://login.microsoftonline.com/$v_tenant_id/oauth2/v2.0/token \\
-d 'client_id=$v_client_id' \\
-d 'scope=https://graph.microsoft.com/.default' \\
-d 'client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer' \\
-d 'client_assertion=$v_jwt' \\
-d 'grant_type=client_credentials'"

v_token=$(eval $v_token_command | grep -o '"access_token":"[^"]*"' | sed 's/"access_token":"//' | sed 's/"//')

# Use the access token to make an authenticated request (e.g., file upload)
v_curl_command="curl -X PUT -H 'Authorization: Bearer $v_token' \\
-H 'Accept: application/json;odata=verbose' \\
--upload-file '$v_file_path' \\
$v_sharepoint_url"

v_curl_output=$(eval $v_curl_command | grep -i error)

# Check for errors
if [ -z "$v_curl_output" ]; then
    echo "File uploaded successfully!"
else
    echo "Error uploading file: $v_curl_output"
fi






$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
#!/bin/bash

# Define required variables
v_client_id="your-client-id"  # Replace with your actual Client ID
v_tenant_id="your-tenant-id"  # Replace with your actual Tenant ID
v_cert_thumbprint="your-cert-thumbprint"  # Replace with your certificate thumbprint
v_key_cert_path="/path/to/your/privatekey.pem"  # Replace with your private key file path
v_key_password="your-key-password"  # Replace with your key password
v_file_path="/path/to/your/file.txt"  # Replace with the path to the file you want to upload
v_certificate_file_path="/path/to/certificate/files"  # Replace with the path to your certificate files
v_env_cert="your-env-cert.pem"  # Replace with your environment certificate filename
v_env_cert_key="your-env-cert-key.pem"  # Replace with your environment certificate key filename

# Base64 URL encoding function
base64url() {
    openssl base64 -e | tr -d '=' | tr '/+' '_-' | tr -d '\n'
}

# Function to create a JWT
create_JWT() {
    v_app_id=$1
    v_aud="https://login.microsoftonline.com/$2/oauth2/v2.0/token"
    v_sub="$1"
    v_jti=$(openssl rand -hex 32)
    v_x5t=$3
    v_now=$(date +%s)
    v_exp=$((v_now + 540))
    v_header_raw="{\"alg\":\"RS256\",\"typ\":\"JWT\",\"x5t\":\"$v_x5t\"}"
    v_header=$(echo -n "$v_header_raw" | base64url)
    v_payload_raw="{\"aud\":\"$v_aud\",\"exp\":\"$v_exp\",\"iss\":\"$v_app_id\",\"nbf\":\"$v_now\",\"sub\":\"$v_sub\",\"iat\":\"$v_now\",\"jti\":\"$v_jti\"}"
    v_payload=$(echo -n "$v_payload_raw" | base64url)
    v_header_payload="$v_header.$v_payload"
    v_signature=$(echo -n "$v_header_payload" | openssl dgst -sha256 -binary -sign $4 -passin pass:$5 | base64url)
    v_jwt="$v_header_payload.$v_signature"
    echo $v_jwt
}

# Generate the JWT assertion
v_assertion=$(create_JWT $v_client_id $v_tenant_id $v_cert_thumbprint $v_key_cert_path $v_key_password)

# Get token from Azure AD principal by using client assertion
v_token_command="curl -k --request POST --data-urlencode client_id=$v_client_id \
--data-urlencode scope=https://graph.microsoft.com/.default \
--data-urlencode client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer \
--data-urlencode client_assertion=$v_assertion \
--data-urlencode grant_type=client_credentials \
--cacert ${v_certificate_file_path}/${v_env_cert} \
--key ${v_certificate_file_path}/${v_env_cert_key} https://login.microsoftonline.com/$v_tenant_id/oauth2/v2.0/token"

# Execute the command to get the access token
v_token=$(eval $v_token_command | grep -o '"access_token":"[^"]*"' | sed 's/"access_token":"//' | sed 's/"//')

# Check if the token was successfully retrieved
if [ -z "$v_token" ]; then
    echo "Error: Failed to retrieve access token"
    exit 1
fi

# Use the access token to make an authenticated request (e.g., file upload)
v_command="curl -X PUT -H 'Authorization: Bearer $v_token' -H 'Content-Type: text/html' -T '$v_file_path' --silent --show-error 2>&1"

# Execute the authenticated command and capture the output
v_curl_output=$(eval $v_command)

# Check for errors in the curl output
if echo "$v_curl_output" | grep -qi "error"; then
    echo "Error uploading file: $v_curl_output"
    exit 1
else
    echo "File uploaded successfully!"
fi


